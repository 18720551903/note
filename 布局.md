# 1. grid 布局

## 1.1 grid

 采用网格布局的区域，称为"容器" 

1. display:grid;

   > 容器元素是块级元素
   >
   > 容器元素是采用网格布局的元素

2. display:inline-grid;

   > 容器元素行内元素 

## 1.2 grid-template系列

1. 属性
   1.  grid-template-coloums  属性定义每一列的列宽， 
   2.  grid-template-rows  属性定义每一行的行高 

2. 属性值

   1. **px、em等单位**，可以是百分比; 

   2.  **repeat()函数**，repeat函数接收两个参数，第一个是要重复的次数(可以是auto-fill，表示自动填充。 )，第二个参数是要重复的值; 

      > grid-template-columns:repeat(2, 40*px* 50*px*);  
      >
      > 相当于 grid-template-columns:40*px* 50*px* 40*px* 50*px*；

   3.  **fr(片段)**，把容器分成片段; 

       为了方便表示比例关系，网格布局提供了`fr`关键字（fraction 的缩写，意为"片段"）。如果两列的宽度分别为`1fr`和`2fr`，就表示后者是前者的两倍。 

      > ```css
      > .container {
      >   display: grid;
      >   grid-template-columns: 1fr 2fr;
      > }
      > 
      > //
      > grid-template-columns: repeat(12, 1fr);
      > ```

   4.  **minmax()函数** 产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。 

      > ```css
      > grid-template-columns: 1fr 1fr minmax(100px, 1fr);
      > ```

   5.  **auto关键字**，表示由浏览器自己决定长度 (自动填充剩余的距离)

      >  **网格线名称**，使用方括号，指定每一根网格线的名字 
      >
      >  grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4]; 

3. 代码示例

```js
 html,
    body {
      height: 100%;
    }

    .container {
      width: 100%;
      height: 100%;
      display: inline-grid;
      grid-template-columns: 40px 50px auto 50px 40px;
      grid-template-rows: 25% 100px auto;
    }
```

## 1.3 grid-auto-flow 

1. 属性值

- 默认值是`row`，即"先行后列"。

- column`，变成"先列后行"。 如图

  <img src="\pic\grid_auto_flow.png" style="zoom:50%;" />

  

- row dense  表示"先行后列"，并且尽可能紧密填满，尽量不出现空格。 

  - 如果让1号项目和2号项目各占据两个单元格，然后在默认的`grid-auto-flow: row`情况下，会产生空白区域如图

    <img src="\pic\grid_gap.png" style="zoom:50%;" />

  -  现在修改设置，设为`row dense`，表示"先行后列"，并且尽可能紧密填满，尽量不出现空格。 

    <img src="./pic\grid_no_gap.png" style="zoom:50%;" />

- column dense 

## 1.4 grid-area

 网格布局允许指定"区域"（area），一个区域由单个或多个单元格组成。`grid-template-areas`属性用于定义区域。 

```css
    div:nth-child(1) {
      grid-area: a;
    }
    div:nth-child(2) {
      grid-area: b;
    }
    div:nth-child(3) {
      grid-area: c;
    }
	...
.container {
  display: grid;
  grid-template-columns: 100px 100px 100px;
  grid-template-rows: 100px 100px 100px;
  grid-template-areas: 'a b c'
                       'd e f'
                       'g h i';
}
上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应这九个单元格。

多个单元格合并成一个区域的写法如下。
    div:nth-child(1) {
      grid-area: a;
    }
    div:nth-child(2) {
      grid-area: b;
    }
    div:nth-child(3) {
      grid-area: c;
    }
    .container {
      display: grid;
      grid-template-columns: 100px 100px 100px;
      grid-template-rows: 100px 100px 100px;
      grid-template-areas: 'a a a'
        				   'b b b'
        				   'c c c';
    }
```

## 1.5 grid-auto系列

- grid-auto-rows 属性

- grid-auto-columns 属性

  ```css
  .container {
    display: grid;
    grid-template-columns: 100px 100px 100px;
    grid-template-rows: 100px 100px 100px;
    grid-auto-rows: 50px; 
  }
  
  ```

上面代码指定新增的行高统一为50px（原始的行高为100px）

<img src="\pic\grid_auto.png" style="zoom:50%;" />

##  1.6 项目属性

 容器内部采用网格定位的子元素，称为"项目" 

1. `grid-column-start`属性：左边框所在的垂直网格线
2. `grid-column-end`属性：右边框所在的垂直网格线
3. `grid-row-start`属性：上边框所在的水平网格线
4. `grid-row-end`属性：下边框所在的水平网格线

代码

```js
.item-1 { //给某个元素设置
  grid-column-start: 1;
  grid-column-end: 3;
  grid-row-start: 2;
  grid-row-end: 4;
}
```

图例

<img src="pic\grid.png" style="zoom:50%;" />

## 1.7 对齐方式

一、 网格布局区域在父容器下的对齐方式

1. 属性

   - justify-content 属性
   - align-content 属性
   - place-content 属性  `place-content`属性是`align-content`属性和`justify-content`属性的合并简写形式。 

2. 属性值

   - start 

   - end 

   - center 

   - stretch 

   - space-around 

   - space-between 

   - space-evenly  项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。 

     ![](.\pic\grid_content.png)

   

二 、 元素对齐方式

1. 行对齐

   - justify-items:start;
   - justify-items:end;
   - justify-items:center;
   - justify-items:stretch;

2. 列对齐

   - align-items:start;
   - align-items:end;
   - align-items:center;
   - align-items:stretch;

3.  `place-items`

   是`align-items`属性和`justify-items`属性的合并简写形式。 

   ```css
   place-items: <align-items> <justify-items>;
   
   place-items: start end;
   ```

三 、 单个元素对齐方式

1. 行对齐
   - justify-self:start;
   - justify-self:end;
   - justify-self:center;
   - justify-self:stretch;
2. 列对齐
   - align-self:start;
   - align-self:end;
   - align-self:center;
   - align-self:stretch;

## 1.8 网格间隙

1. 属性

   - column-gap：值；

   - row-gap：值；

   -  `gap`属性是`column-gap`和`row-gap`的合并简写形式，语法如下 

     > ```css
     > .container {
     >   gap: 20px 20px;
     > }
     > 省略了第二个值，浏览器认为第二个值等于第一个值。
     > ```

2. 代码

```js
.container{
    display：grid；
    grid-template-columns:repeat(3,40px);
    grid-template-rows:repeat(3,40px);
    column-gap:10px;
    row-gap:10px;
}
```

## 1.9 经典布局

1. 圣杯布局

   ```js
   .box{
       display:grid;
       grid-template-columns:100px auto 100px;
   }
   ```

2. 网页容器布局

   ```js
   .container{
       display:grid;
       grid-template-columns:100px auto 100px;
       grid-template-rows:400px 300px 50px;
       grid-template-areas:"header header header"
       "left main right"
       "footer footer footer";
   }
   .container .header{
       grid-area:header;
   }
   
   .container .left{
       grid-area:left;
   }
   .container .main{
       grid-area:main;
   }
   .container .right{
       grid-area:right;
   }
   .container .footer{
       grid-area:footer;
   }
   ```

   <img src="./\pic\grid_container.png" style="zoom:50%;" />

   

   

# 2.rem布局

```js
/**
 * @desc 自适应宽度
 * @param {number} designWidth 设计稿宽带 默认 1920
 * @param {number} maxWidth 最大宽度，缩大到一定程度不在缩大 默认 无限制
 * @param {number} minWidth 最小宽度，缩小到一定程度不在缩小 默认 1366
 * @param {number} base 基准值 默认 100(100px === 1rem)
 */
(({ designWidth = 1920, maxWidth = 2 ** 64, minWidth = 1366, base = 100 }) => {
  autoComputed();
  window.addEventListener('resize', autoComputed);
  function autoComputed() {
    const html = document.documentElement || document.body;
    const limitMax = maxWidth;
    const limitMin = minWidth;
    const scale = document.body.offsetWidth;

    html.style.fontSize =
      (
        ((scale < limitMin ? limitMin : scale > limitMax ? limitMax : scale) /
          designWidth) *
        base
      ).toFixed(2) + 'px';
  }
})({ designWidth: 1920, minWidth: 1366, base: 100 });
```

# 3.flex布局

## flex布局(伸缩布局)

> flex布局也叫做弹性布局、伸缩布局
>
> 布局：其实就是调整元素在水平和垂直方向上的布局方式。

css3在布局中提出了flex布局（弹性布局）的方法，这种布局方式让我们对于元素的排布更加灵活，适应性也更强，在响应式开发中使用的较多。

## 伸缩布局的初体验

> 使用伸缩布局让一个子盒子在父盒子中水平垂直居中

- 之前使用子绝父相完成

- 通过flex布局，三行代码完成

  ```css
  /* 设置当前盒子为弹性盒子*/
  display: flex;
  /* 设置主轴方向的对齐方式：justify-content */
  justify-content: center;
  /* 设置侧轴方向的对齐方式：align-items */
  align-items: center;
  ```

设置了 `display：flex;` 的盒子会变成一个**弹性盒子**。弹性盒子会多出了**主轴**和**侧轴**的概念。

**主轴：** **默认水平向右** （类似于x轴）

**侧轴：**与主轴垂直的就是侧轴，**默认垂直向下**（类似于y轴）

弹性盒子内部的**子元素会默认沿着主轴方向** 排布，默认水平向右布局。（类似于羊肉串）

---

> 接下来学习一些flex布局中相关的属性

## 主轴方向（flex-direction）（了解）

> 弹性盒子中主轴方向默认是水平向右的。
>
> 但是其实可以通过`flex-diretion` 属性修改主轴的方向（一般很少改变）

**取值（主轴方向）：**

|      取值      | 效果（主轴方向） |
| :------------: | :--------------: |
|      row       | 水平向右（默认） |
|  row-reverse   |     水平向左     |
|     column     |     垂直向下     |
| column-reverse |     垂直向上     |



## 主轴对齐方式（justify-content）（重点）

> 元素在主轴上排布，可以通过 `justify-content` 属性设置元素的对齐方式

**取值：**

- **flex-start：向主轴的开始位置对齐**

  > 默认相当于左对齐

  ![flex-start](H:\前端\笔记\就业班\01移动web\mdImg\flex-start.png)

- **flex-end：向主轴的结束位置对齐**

  > 默认相当于右对齐

  ![flex-end](H:\前端\笔记\就业班\01移动web\mdImg\flex-end.png)

- **center：居中对齐**

  ![center](H:\前端\笔记\就业班\01移动web\mdImg\center.png)

- **space-around：让空白环绕盒子显示**

  ![space-around](H:\前端\笔记\就业班\01移动web\mdImg\space-around.png)

- **space-between：让空白只在盒子之间显示**

  ![space-between](H:\前端\笔记\就业班\01移动web\mdImg\space-between.png)

  **space-between：让空白只在盒子之间显示**(中间空格=两端空白宽度的和)

  ![space-between](H:\前端\笔记\就业班\01移动web\mdImg\space-between.png)

  **space-evenly**: **让空白均匀显示**

## 单行侧轴对齐方式（align-items）（重点）

> 可以通过 `align-items` 设置单行元素在侧轴的对齐方式。 

**取值：**

- **flex-start：向侧轴的开始位置对齐**

  ![aflex-start](H:\前端\笔记\就业班\01移动web\mdImg\aflex-start.png)

- **flex-end：向侧轴的结束位置对齐**

  ![aflex-end](H:\前端\笔记\就业班\01移动web\mdImg\aflex-end.png)

- **center：居中对齐**

  ![acenter](H:\前端\笔记\就业班\01移动web\mdImg\acenter.png)

- **stretch：让子盒子的高度拉伸显示（默认值）**

  > 只有当子元素没有高度时，才会有拉伸效果（否则以设置的高度为准）

  ![astretch](H:\前端\笔记\就业班\01移动web\mdImg\astretch.png)

---

## 是否换行（flex-wrap）

> flex布局中，默认是单行显示的，如果子元素的宽度之和超出了父元素的宽度，此时子盒子会默认压缩显示。
>
> 此时，如果需要设置子元素换行显示，可以使用属性 `flex-wrap`

**取值：**

| 属性值 |       效果       |
| :----: | :--------------: |
| nowrap | 不换行（默认值） |
|  wrap  |       换行       |



## 多行侧轴对齐方式（align-content）

> 之前学习的 `align-items` 只是针对于单行元素的侧轴对齐方式。
>
> 如果需要设置多行元素的侧轴对齐方式，此时需要使用 `align-content` 才行

**取值（和align-items差不多）：**

|     取值      |                   效果                   |
| :-----------: | :--------------------------------------: |
|  flex-start   |           向侧轴的开始位置对齐           |
|   flex-end    |           向侧轴的结束位置对齐           |
|    center     |                 居中对齐                 |
|    stretch    | 子元素高度拉伸显示（只有没设高才有效果） |
| space-around  |             空白环绕盒子显示             |
| space-between |           空白只在盒子之间显示           |



**align-items与align-content的区别：**

- 如果子元素没有换行，**只有一行**的时候使用 `align-items`
- 如果子元素有**多行**，此时使用 `align-content`

以下都是给子元素设置的相关属性~

## 分配子元素空间（flex属性）

> 可以通过flex属性设置子元素的分配的空间

**需求：** 让弹性盒子中的三个子元素等分！



**作用：** 按照份数分配父元素主轴（宽度）的剩余空间

> 优先分配具体的宽度，剩余的空间再按照分数分配。

**代码：** `flex:份数;`

**通过flex属性可以很轻松的完成圣杯布局。**



## 子元素排序（order属性）(了解)

> 在不能修改html结构的时候，要求改变子元素的属性，此时可以使用order属性设置

**需求：** 让弹性盒子中第二个子元素显示在左边第一个？？



**作用：** 设置弹性盒子中子元素的排列顺序，**数值越小，排列靠前，默认是0**

**代码：** `order：数字;`



## 单个子元素侧轴对齐方式（align-self）

> 可以通过 `align-self` 属性设置单个子元素侧轴的对齐方式

**需求：** 让父元素中的单行子元素居中，然后让第一个子元素跑到侧轴开始位置！



**作用：** 设置单个子元素在侧轴的对齐方式

**取值（和align-items取值一样）：**

|    取值    |                    效果                    |
| :--------: | :----------------------------------------: |
| flex-start | 向侧轴的开始位置对齐（默认相当于顶部对齐） |
|  flex-end  | 向侧轴的结束位置对齐（默认相当于底部对齐） |
|   center   |                  居中对齐                  |
|  stretch   |  子元素高度拉伸显示（只有没设高才有效果）  |

#响应式布局

## 响应式布局的介绍（了解）

> 响应式布局（respond layout）是Ethan Marcotte在2010年5月份提出的一个概念，简而言之，就是**一个网站能够兼容多个终端（pc、手机、平板）**

## 什么是响应式布局

**早期：** 

> 同一个页面需要开发不同设备的版本，公司开发成本较高

- pc端需要开发写一套页面，专门给pc端看
- 移动端再开发一套页面，专门给移动端看

**响应式布局（记忆）：**

> 同一个页面只需要开发一套网页，公司开发成本较低

- 只需要写一套代码，同时给pc端和移动端看



看看微金所项目~

**响应式开发的原理（记忆）**

***动态根据当前屏幕的宽度，自动改变页面中盒子的宽度、盒子的显示或隐藏***



**响应式开发的优缺点**

**优点：** 

- 对于不同设备只需要开发一套网页即可，公司开发成本较低
- 一套网页可以适配多个终端

**缺点： **

- 一个页面需要兼容多个终端，考虑的情况多种，开发效率较慢
- 代码会更多，网页的加载速度较慢



## 响应式开发的现状

> 在国内并不是很流行，国外较多

- 如果已经有了一套pc端网页，此时直接再写一套移动端网页即可，此时不需要使用响应式布局（比如：京东、淘宝）

- 如果开发一套网页都没有，是**新建的项目**，此时可以考虑使用响应式，写一套即可兼容多个设备。

- 比较**简单的网页**，可以考虑使用响应式，但是复杂的网页考虑的情况会很多，一般不用。

  

## 响应式开发与pc+移动开发的比较

|   分类   |               pc端+移动端网页开发                |                     响应式开发                     |
| :------: | :----------------------------------------------: | :------------------------------------------------: |
| 应用场景 |   已有pc端网页，只需要再开发一套移动端网页即可   | 对于新建网页，可以使用响应式写一套兼容多个设备即可 |
| 开发效率 |             针对性强，**开发效率高**             |     需要兼容各种终端，考虑情况更多，开发效率低     |
| 适配情况 | 只能适配移动端或者PC端，其他设备（平板）体验较差 |                可以**适配各种终端**                |
| 加载速度 |               代码简洁，**加载快**               |                代码相对复杂，加载慢                |

##### -------------------

## 响应式开发的屏幕分类

> 在响应式开发中需要动态根据屏幕的宽度改变样式，但是不可能每变化1px就改变样式。
>
> 在响应式开发中，把各种屏幕宽度分为四大类！！

## 设备屏幕的分类

|  分类名称  |    宽度范围     |
| :--------: | :-------------: |
| 超小屏设备 |    0 ~ 768px    |
|  小屏设备  |  768px ~ 992px  |
|  中屏设备  | 992px ~ 1200px  |
|  大屏设备  | 1200px ~ 正无穷 |



![1](H:\前端\笔记\就业班\01移动web\mdImg\1.png)



## 媒体查询

> 刚刚说了响应式原理是：***动态根据当前屏幕的宽度，自动改变页面中盒子的宽度、盒子的显示或隐藏***
>
> 所以需要根据不同屏幕的宽度改变样式。
>
> 可以通过css3中新增的媒体查询完成效果。

**媒体查询（Media Query）：**是CSS3新增的方法，可以通过动态查询屏幕的宽度，根据不同的屏幕宽度设置样式是否生效！！

**语法：** 

```css
@media screen and (条件) {
    选择器......
}
```

**作用：** 只有当屏幕宽度满足条件时，媒体查询中的选择器才能生效！！！

**注意点：** 媒体查询仅仅只是控制选择器是否生效，不会提升选择器的优先级！！

> 具体谁说了算，还是需要看优先级

**条件：**

- `min-width`：样式生效的屏幕最小宽度

  > 只有当屏幕宽度大于等于该宽度时，样式才会生效

  ```css
  /* 样式生效的最小宽为600px——》只有当屏幕宽度大于等于600px时，样式才会生效！！*/
  @media screen and (min-width:600px) {
      div {
          width: 400px;
          height: 400px;
          background-color: green;
      }
  }
  ```

  

- `max-width` ：样式生效的屏幕最大宽度

  > 只有当屏幕宽度小于等于该宽度时，样式才会生效

  ```css
  /* 样式生效的最大宽为800px——》只有当屏幕宽度小于等于800px时，样式才会生效*/
  @media screen and (max-width:800px) {
      div {
          width: 400px;
          height: 400px;
          background-color: blue;
      }
  }
  ```

  

- `width` ：样式生效的宽度

  > 只有当屏幕宽度正好等于该宽度时，样式才会生效

  ```css
  /* 样式只在700px宽度的时候才会生效 */
  @media screen and (width:700px) {
      div {
          width: 400px;
          height: 400px;
          background-color: purple;
      }
  }
  ```

##### ヾ(๑╹◡╹)ﾉ" 如果需要在600~800之间样式生效，怎么写？？

> 一个媒体查询中可以同时写多个条件，中间通过and连接即可

```css
/* 样式在 600~800中间生效 */
@media screen and (min-width:600px) and (max-width:800px) {
    div {
        width: 400px;
        height: 400px;
        background-color: orange;
    }
}
```



## 使用媒体查询完成响应式适配

> 可以通过媒体查询实现不同终端的布局和样式的切换，完成响应式布局。



**需求：**手动设置全局容器.container的响应式适配四种屏幕。

```css
/*
需求：
	超小屏幕: 0 - 768px      	版心：100% 	背景颜色：绿色
	小屏设备: 768px - 992px  	版心：750px 	背景颜色：蓝色
	中屏设备: 992px - 1200px 	版心：970px 	背景颜色：黄色
	大屏设备: 1200 ~  正无穷     版心：1170px   背景颜色：粉色
*/
```



**弊端：现在只有一个div，要做一套响应式布局，就需要如此多的代码，非常的麻烦。真正开发中我们会借助一些响应式的框架，比如bootstrap。**